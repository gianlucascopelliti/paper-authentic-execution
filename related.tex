\section{Related Work}
\label{sec:related-work}

\subsection{TEE frameworks}

In recent years, \acp{TEE} have gained more and more popularity in both research
and industry, due to their properties and the security guarantees they provide.
However, developing \ac{TEE} applications is not trivial as software developers
are normally required to have some expertise in the field; moreover, more and
more \acp{TEE} are emerging nowadays, which makes it more difficult to write
heterogeneous applications or simply to port an application from one \ac{TEE} to
another. 

To this end, Keystone~\cite{lee2020keystone} is an open source framework for
building customized \acp{TEE}; it provides generic primitives such as isolation
and attestation, and hardware manufacturers and programmers can tailor the
\ac{TEE} design based on what they actually need. More software-based frameworks
such as OpenEnclave~\cite{openenclave} and Google Asylo~\cite{googleasylo} aim
to provide a general API for writing enclave applications, allowing developers
to write code that is not tied to a specific \ac{TEE} and can therefore be
easily ported to multiple platforms. Our framework uses a different approach,
which consists of abstracting the \ac{TEE} layer away from developers in order
to write enclave applications just like normal ones. Other projects such as
Enarx~\cite{enarx}, follow the same principles as ours, although they mainly
focus on high-end \acp{TEE} such as Intel \ac{SGX}, TDX, and AMD SEV. To the
best of our knowledge, our framework is the only one that support heterogeneous
architectures, combining high-end systems, IoT devices, and small embedded
microcontrollers.

Process-based \acp{TEE} such as Intel \ac{SGX} strive in minimizing the
\ac{TCB}, as only the critical part of an application can be moved to the
enclave. However, this comes with significant performance penalties, especially
when crossing the boundary between the enclave and the untrusted domain.
Instead, VM-based \acp{TEE} such as AMD SEV~\cite{kaplan2016amd}, Intel
TDX~\cite{intelTdx} and ARM CCA~\cite{li2022design} are substantially better in
terms of performance, but have a much bigger attack surface as the entire
virtual machine is part of the \ac{TCB}. As future work, we might investigate
the use of VM-based \acp{TEE} combined with lightweight operating systems such
as the formally-verified seL4 microkernel~\cite{klein2009sel4}.

\subsection{Mutually authenticated enclaves}
\label{sec:relwork:mutual}
%
At deployment time, our framework leverages symmetric connection keys to
establish secure and mutually-authenticated channels between modules. Modules do
not need to explicitly attest each other, but rather they rely on the fact that
connection keys are securely distributed to modules \textit{only} after
successful attestation. The implicit assumption here is that such keys are known
only by the modules and their deployer, and are always kept in secure memory and
transmitted over encrypted channels. A similar idea was applied to the
automotive scenario by creating a mesh of mutually-authenticated Sancus enclaves
to provide integrity and authenticity of CAN messages exchanged between the ECUs
of a vehicle~\cite{vanbulck_2017vulcan}.

In \cite{zheng2021secure}, multiple Intel \ac{SGX} enclaves of an application
establish mutual trust during the initialization of TLS sessions, using
certificates previously generated by central servers upon successful
attestation. Marblerun~\cite{marblerun} uses the same principle to create a
service mesh between enclaves in a Kubernetes cluster. Our framework, instead,
relies on symmetric encryption for the establishment of secure channels, as
public-key cryptography is not supported on small microcontrollers like Sancus.
Although asymmetric encryption and client certificates seem a better choice in
terms of key management and authentication, we decided to leverage symmetric
connection keys even on Intel \ac{SGX} and TrustZone in order to allow
communication with Sancus modules.

\subsection{Secure I/O}
\label{rel-work:secureio}

There are several intensive previous solutions aiming to provide a trusted path
between an authorized trusted application and I/O devices that guarantees the
integrity and authenticity of I/O data. McCune et al.~\cite{bite} have proposed
a BitE framework that leverages a trusted mobile device to establish an
encrypted and authenticated input channel between I/O devices and an application
running on a TPM-equipped untrusted platform. However, data inside the host
platform is not isolated, hence the OS kernel must be part of the TCB.
Bumpy~\cite{bumpy}, a succeeding work from the same research group, addresses
this limitation by relying on the Flicker TEE~\cite{flicker} and using the
encryption-capable keyboard to provide a safe pathway from input devices through
untrusted environments. Bumpy uses dedicated hardware and hence cannot
generalize to arbitrary I/O devices. Our approach to trusted I/O improves over
Bumpy by greatly reducing the size of the software TCB, from a full OS to less
than 1 kLOC. By using Sancus as a TEE, we enable the integration of attestable
software and I/O encryption directly into the input device. When communicating
with a host that interacts with Sancus nodes, technologies such as Flicker,
TrustZone or Intel \ac{SGX} can be used to protect host services and to further
reduce the TCB.

Several studies investigated a hypervisor-based approach. The techniques offered
by Zhou et al.~\cite{Zhou1, Zhou2} aim to establish a trusted path between an
input peripheral and an application using a hypervisor to run the untrusted OS
and application endpoints providing the necessary device drivers in separate
VMs. DriverGuard~\cite{driverguard} is a hypervisor-based mechanism that
leverages a combination of cryptographic and virtualization techniques to
protect I/O device control, I/O data flows against attacks from a malicious
guest kernel. These systems rely on hardware interfaces, peripherals, and the
USB bus to behave according to specification. Rogue devices on the USB bus, e.g.
hardware keyloggers, can intercept messages between an I/O device and the host.
Although our design focuses on integrity guarantees, our prototype protects
communication channels using authenticated encryption. A more recent work,
SGXIO~\cite{SGXIO}, provides support for generic, trusted I/O paths for enclaves
in Intel \ac{SGX} by a composite of TPM, Intel \ac{SGX}, and hypervisor
techniques. Thus, SGXIO introduces a formally verified hypervisor (seL4 is
recommended) to establish a trusted path while Intel \ac{SGX} is in charge of
protecting user applications from an untrusted OS. This approach improves upon
existing generic trusted paths for x86 systems using Intel \ac{SGX}'s easy
programming model.
% 
Similarly, Aurora~\cite{Aurora} utilizes a hypervisor running in the Secure
Management Mode (SMM) of Intel x86 processors as well drivers in the Driver
eXecution Environment of open-source UEFI firmware to implement a concept not
unlike the protected driver modules from our work. A TPM is used to store Intel
Boot Guard measurements of the firmware and hypervisor, enabling mutual
attestation between the SMM side and application modules in SGX enclaves.
Omitting a hypervisor layer, BASTION-SGX~\cite{BASTION-SGX} introduces a trusted
Bluetooth controller and application support to establish a trusted channel
between SGX enclaves and Bluetooth devices.  SGX-USB~\cite{SGX-USB}, instead,
places a proxy device between the host and an I/O peripheral connected through
USB, to establish a secure path to an Intel \ac{SGX} enclave. Unlike the other
SGX-based solutions, SGX-USB does not rely on software modifications or
additional trusted hardware in the host platform.

Fidelius~\cite{eskandarian2019fidelius} leverages only hardware settings with no
reliance on hypervisor security assumptions to assist the establishment of a
trusted path from input and output peripherals to a hardware enclave. More
specifically, Fidelius utilizes a trusted dongle (e.g., Raspberry Pi) to protect
the entire I/O path between the keyboard/screen and a small JavaScript
interpreter that runs inside an Intel \ac{SGX} enclave during web browsing
sessions under a compromised OS and browser. The trusted dongle captures user
input and sends a stream of encrypted keystrokes to an attested local enclave.
Then, the web enclave decrypts and updates the state of the relevant trusted
input field and eventually forwards it to the remote server. In the opposite
direction, a series of encrypted overlays are sent from the enclave to the
display. The trusted path between a dongle and the web enclave is established
through pre-shared symmetric keys. Conversely, the web enclave and remote server
attest each other and establish a secure channel. Fidelius uses an LED indicator
on each dongle and a status bar on the screen to ensure the establishment of the
trusted paths; however, this leads to a high cognitive load on the users as they
must monitor continuously different security indicators. Fidelius leverages a
trusted external device to guarantee the integrity and authenticity of the
transferred I/O data, while our solution for secure I/O relies only on the
isolation and attestation properties in Sancus and does not suffer from
micro-architectural attacks and relay attacks.

ARM TrustZone provides isolated execution combined with generic trusted I/O
paths. In TrustZone, different peripherals, including parts of RAM, IO devices,
and interrupts, can be dynamically configured by a set of hardware controllers
to be accessible only in the secure mode. This is achieved by the reflection of
the NS bit into the respective peripheral. In contrast to Intel \ac{SGX},
TrustZone assumes that all secure application processes are trusted and does not
isolate them in hardware. However, several prior works take the advantage of
TrustZone to establish a trusted I/O path with much focus on balancing the size
of TCB against functionality. For example, TrustUI~\cite{TrustUI} builds trusted
paths by splitting device drivers into an untrusted backend and a trusted
front-end. The two parts communicate through shared memory by leveraging proxy
modules running in both worlds. Similarly, TruZ-Droid~\cite{Truz-droid} runs
only half part of the HTTP and SSL protocols in the secure world to reduce the
TCB size. VeriUI~\cite{veriUI} proposes a login protection mechanism by moving
all layers of the communication stack and UI library into TrustZone.
TrustOTP~\cite{TrustOTP} relies on tiny drivers running in the secure world to
protect the one-time password display. Secure I/O in TrustZone is a
well-researched topic that has got a great deal of attention in the past years.
Apart from the projects described above, many others exist in the
literature~\cite{TrustPay,TruzView,Adattester,Vbutton}. More recently, a notion
of trusted I/O was also implemented in Android smartphones to protect user
transactions~\cite{ProtectedConfirmation}. In our work, we did not implement a
secure I/O solution for TrustZone, but rather we interfaced Sancus-enabled I/O
devices with Intel \ac{SGX} and TrustZone enclaves, providing exclusive and
confidential access to isolated host drivers without trusting the underlying
communication channels.

Efforts have recently been made to enhance \acp{TEE} by incorporating hardware
acceleration, particularly GPUs. This enables software modules to exclusively
access external devices for computationally intensive tasks, such as machine
learning model training. Several academic projects propose hardware extensions
to GPUs to enable isolation and strict access control, including
Graviton~\cite{volos2018graviton}, HIX~\cite{jang2019heterogeneous}, and
HETEE~\cite{zhu2020enabling}. StrongBox~\cite{deng2022strongbox} utilizes
TrustZone extensions already present in ARM devices to provide a solution
without requiring hardware changes. This trend has also influenced commercial
products, such as NVIDIA's new H100 Tensor Core GPU that supports confidential
computing~\cite{nvidiaCC}, and Intel TDX Connect, which offers extensions to the
TDX architecture to securely assign I/O devices to trusted
domains~\cite{intelTdxConnect}. Our architecture can utilize hardware
acceleration to enhance the use cases we are considering
(\cref{sec:system,eval:intro}). For instance, it can be used to process sensor
data for computing statistics or training machine learning models.